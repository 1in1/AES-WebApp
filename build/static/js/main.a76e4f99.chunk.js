(this["webpackJsonpcrypto-webapp"]=this["webpackJsonpcrypto-webapp"]||[]).push([[0],[,,,,,function(e,t,a){e.exports=a(19)},,,,,function(e,t,a){},function(e,t,a){},function(e,t,a){},function(e,t,a){},,,,,,function(e,t,a){"use strict";a.r(t);var n=a(0),r=a.n(n),i=a(4),l=a.n(i),o=(a(10),a(1));a(11);var s=function(e){return r.a.createElement("div",{className:"page"},r.a.createElement("h1",null,"AES Web App thing"),r.a.createElement("p",null,"This is a very small web app written to give me a bit of experience with React more than anything else. It gives an explanation of the AES algorithm that should be more than enough to allow someone with a basic understanding of fields to implement the algorithm themselves (minus key expansion - probably coming soon), but hopefully with a little bit more explanation of what's actually happening to the data. I'm planning to have more detailed explanations appear when the reader hovers over sections of interest. I'd only written my first line with React two days before starting this, so there could well be things that break! Let me know if this happens :) The source is available on my GitHub ",r.a.createElement("a",{href:"https://github.com/1in1/AES-WebApp"},"here"),"."),r.a.createElement("p",null,"This only covers the encryption direction - obviously all of these steps are invertible, and it is very easy to find their inverses."),r.a.createElement("p",null,"The ",r.a.createElement("a",{href:"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf"},"FIPS specification")," has been my information source, and invaluable for writing this."))},c=(a(12),function(e){return r.a.createElement("div",{className:"cell"},e.value.toString(16))});var u=function(e){return r.a.createElement("div",{className:"box"},e.data.map((function(e,t){return r.a.createElement(c,{key:t,value:e})})))};a(13);var m=function(e){var t=Object(n.useState)(!1),a=Object(o.a)(t,2),i=a[0],l=a[1];return r.a.createElement("div",{class:"hoverable",onMouseEnter:function(){return l(!0)},onMouseLeave:function(){return l(!1)}},e.under,i&&r.a.createElement("div",{class:"reveal"},e.over))};var h=function(e){var t=e.tex;return r.a.createElement("div",{className:"page"},r.a.createElement("h2",null,"Prerequisites"),r.a.createElement("p",null,"For Rijndael, we work in the finite field of order ",r.a.createElement(t,null,"$ 2^8 = 256$"),", which we denote ",r.a.createElement(t,null,"$\\mathbb{F}(2^8)$")," throughout. This is a pretty large object to try and think about, so it will help us to instead consider an isomorphism to a slightly nicer object. The authors of Rijndael chose to use:"),r.a.createElement(m,{under:r.a.createElement(t,{displayMode:!0},"$$\\mathbb{F}(2^8) \\cong \\frac{\\mathbb{F}(2)[x]}{(x^8 + x^4 + x^3 + x + 1)}$$"),over:r.a.createElement("p",null,"Why does this work? ",r.a.createElement(t,null,"$\\mathbb{F}(2)$")," is a field by definition, so its polynomial ring is a Euclidian domain. If we can quotient by a polynomial of order 8, then all elements in the quotient have a unique non-zero representative of degree strictly less than 8, so the quotient ring will be of the correct order. Since ",r.a.createElement(t,null,"$ x^8 + x^4 + x^3 + x + 1 $")," is a prime element in this ring, this quotient is an integral domain. All finite integral domains are fields, and finite fields are unique up to isomorphism, and so this is the field we want.")}),r.a.createElement("p",null,"It turns out this is a particularly nice object to study for a couple of reasons. Firstly, and most obviously, the width of a byte is 8, so the field has as many elements as there are possible bytes. Via the isomorphism above, we can represent each element as a polynomial of degree strictly less than 8, with coefficients in ",r.a.createElement(t,null,"$\\mathbb{F}(2)$"),", which may be stored as a single byte. Here we will represent numbers in this field like this, with the bytes in green hexadecimal, e.g."),r.a.createElement(t,{displayMode:!0},"$x^5 + x^3 + x^2 = {\\color{green}\\{1c\\}}$"),r.a.createElement("p",null,"We also note that each element is its own additive inverse; this is again immediately clear by thinking about the isomorphism. The really useful reason for writing our elements out in this form is that addition is exactly the same operation as XOR'ing the corresponding byte representation. This makes calculations very, very fast."),r.a.createElement(m,{under:r.a.createElement("p",null,"Rijndael works on two-dimensional blocks, which each have four rows and a fixed number of columns. The typical number of columns is four, so we chunk our plaintext into blocks of 16 bytes, and encrypt each block individually. We call this array the ",r.a.createElement("i",null,"state")," when describing the algorithm. The box below represents a state of the algorithm - you can edit these to see how the algorithm behaves on different data."),over:r.a.createElement("p",null,"We fill the state matrix by going down each column in turn, working left to right. We DON'T fill the state matrix by going across each row, working top to bottom. If we want to extend the algorithm to other modes which work on longer (or even indeterminate) length rows, this is essential.")}),r.a.createElement("div",{className:"boxContainerOuter"},r.a.createElement("div",{className:"boxContainerInner"},"State:",r.a.createElement(u,{data:e.input}))),r.a.createElement("p",null,"As with all encryption schemes, we begin with two pieces of information: the ",r.a.createElement("i",null,"plaintext")," and the ",r.a.createElement("i",null,"key"),". The cipher consist of several rounds of the same four basic operations. To this end, we expand a given key into several, and one is used for each round - this is called ",r.a.createElement("i",null,"key expansion"),", and produces a set of ",r.a.createElement("i",null,"round keys"),". Each round consists of the following steps, in the following order:"),r.a.createElement("div",{className:"listContainer"},r.a.createElement("ul",null,r.a.createElement("li",null,"Add Round Key"),r.a.createElement("ul",null,"-Repeat-",r.a.createElement("li",null,"Sub Bytes"),r.a.createElement("li",null,"Shift Rows"),r.a.createElement("li",null,"Mix Colums"),r.a.createElement("li",null,"Add Round Key"),"-9 times-"),r.a.createElement("li",null,"Sub Bytes"),r.a.createElement("li",null,"Shift Rows"),r.a.createElement("li",null,"Add Round Key"))),r.a.createElement("p",null,"Note that we don't mix columns on the final go round; it adds no extra diffusion. Note also that 10 rounds is relatively arbitrary - extra rounds were added during the design competition as a buffer to mitigate a known attack."))},d=[0,1,141,246,203,82,123,209,232,79,41,192,176,225,229,199,116,180,170,75,153,43,96,95,88,63,253,204,255,64,238,178,58,110,90,241,85,77,168,201,193,10,152,21,48,68,162,194,44,69,146,108,243,57,102,66,242,53,32,111,119,187,89,25,29,254,55,103,45,49,245,105,167,100,171,19,84,37,233,9,237,92,5,202,76,36,135,191,24,62,34,240,81,236,97,23,22,94,175,211,73,166,54,67,244,71,145,223,51,147,33,59,121,183,151,133,16,181,186,60,182,112,208,6,161,250,129,130,131,126,127,128,150,115,190,86,155,158,149,217,247,2,185,164,222,106,50,109,216,138,132,114,42,20,159,136,249,220,137,154,251,124,46,195,143,184,101,72,38,200,18,74,206,231,210,98,12,224,31,239,17,117,120,113,165,142,118,61,189,188,134,87,11,40,47,163,218,212,228,15,169,39,83,4,27,252,172,230,122,7,174,99,197,219,226,234,148,139,196,213,157,248,144,107,177,13,214,235,198,14,207,173,8,78,215,227,93,80,30,179,91,35,56,52,104,70,3,140,221,156,125,160,205,26,65,28];var f=function(e){var t=Object(n.useState)("00"),a=Object(o.a)(t,2),i=a[0],l=a[1];return r.a.createElement("div",{class:"inverse"},r.a.createElement("label",{for:"inverseInput"},"Try it - inverse of: "),r.a.createElement("input",{type:"text",value:i.text,onChange:function(e){if(""===e.target.value)l({text:"",valid:!1});else{var t=parseInt(e.target.value,16);t>=0&&t<256&&l({text:e.target.value,valid:!0})}},placeholder:e.default,id:"inverseInput",style:{width:20}}),r.a.createElement("p",null,i.valid&&d[parseInt(i.text,16)].toString(16)))};var b=function(e){var t=e.initial.map((function(e){return e.toString(16)}));return r.a.createElement("div",{className:"editBox"},t.map((function(a,n){return r.a.createElement("div",{className:"cell"},r.a.createElement("input",{type:"text",value:a,onChange:function(a){if(""===a.target.value)t[n]="00",e.editHandler(t.map((function(e){return parseInt(e,16)})));else{var r=parseInt(a.target.value,16);r>=0&&r<256&&(t[n]=a.target.value,e.editHandler(t.map((function(e){return parseInt(e,16)}))))}}}))})))},p={toBinArray:function(e){for(var t=[],a=0;a<8;a++)t[a]=e>>a&1;return t},toInt:function(e){return e.reverse().reduce((function(e,t){return 2*e+t}))},xorVec:function(e,t){var a=[];for(var n in e)a[n]=e[n]^t[n];return a},andVec:function(e,t){var a=[];for(var n in e)a[n]=e[n]&t[n];return a},addVec:function(e,t,a){var n=[];for(var r in e)n[r]=a(e[r],t[r]);return n}},v=[[1,1,1,1,1,0,0,0],[0,1,1,1,1,1,0,0],[0,0,1,1,1,1,1,0],[0,0,0,1,1,1,1,1],[1,0,0,0,1,1,1,1],[1,1,0,0,0,1,1,1],[1,1,1,0,0,0,1,1],[1,1,1,1,0,0,0,1]];function E(e){var t=a(3),n=p.toBinArray(e.value),i=[0,0,0,0,0,0,0,0];for(var l in n)n[l]&&(i=p.xorVec(i,v[l]));var o=p.xorVec(i,[1,1,0,0,0,1,1,0]);return r.a.createElement(t,null,"$$\n            \\begin{bmatrix} 1&0&0&0&1&1&1&1\\\\1&1&0&0&0&1&1&1\\\\1&1&1&0&0&0&1&1&\\\\1&1&1&1&0&0&0&1\\\\1&1&1&1&1&0&0&0\\\\0&1&1&1&1&1&0&0\\\\0&0&1&1&1&1&1&0\\\\0&0&0&1&1&1&1&1 \\end{bmatrix}\n            \\begin{bmatrix}"+n.join("\\\\")+"\\end{bmatrix}\n            +\n            \\begin{bmatrix} 1\\\\1\\\\0\\\\0\\\\0\\\\1\\\\1\\\\0 \\end{bmatrix}\n            =\n            \\begin{bmatrix}"+i.join("\\\\")+"\\end{bmatrix}\n            +\n            \\begin{bmatrix} 1\\\\1\\\\0\\\\0\\\\0\\\\1\\\\1\\\\0 \\end{bmatrix}\n            =\n            \\begin{bmatrix}"+o.join("\\\\")+"\\end{bmatrix}\n            = "+p.toInt(o).toString(16)+"\n        $$")}var g=function(e){var t=Object(n.useState)("00"),a=Object(o.a)(t,2),i=a[0],l=a[1];return r.a.createElement("div",{class:"affine"},r.a.createElement("label",{for:"affineInput"},"Try it - transform of: "),r.a.createElement("input",{type:"text",value:i.text,onChange:function(e){if(""===e.target.value)l({text:"",valid:!1});else{var t=parseInt(e.target.value,16);t>=0&&t<256&&l({text:e.target.value,valid:!0})}},placeholder:e.default,id:"affineInput",style:{width:20}}),r.a.createElement("p",null,i.valid&&r.a.createElement(E,{key:i.text,value:parseInt(i.text,16)})))},y=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];var w=function(e){var t=Object(n.useState)(!1),a=Object(o.a)(t,2),i=a[0],l=a[1],s=Object(n.useState)(e.input),c=Object(o.a)(s,2),h=c[0],d=c[1],p=e.tex;return r.a.createElement("div",{className:"page"},r.a.createElement("h2",null,"Substitute Bytes"),r.a.createElement("p",null,"The first step in a round of Rijndael is to swap each byte with another. This is conceptually done in two operations. Let ",r.a.createElement(p,null,"$\\color{green}{\\{p\\}}$")," be our input."),r.a.createElement("p",null,"First, we substitute this with its multiplicative inverse in ",r.a.createElement(p,null,"$ \\mathbb{F}(2^8) $. Of course, $\\color{green}{\\{00\\}}$")," has no such inverse, but we define this to be self-inverse to make everything work."),r.a.createElement(f,{default:"00"}),r.a.createElement(m,{under:r.a.createElement("p",null,r.a.createElement(p,null,"Let $ {\\color{green}\\{p\\}^{-1}} = {\\color{green}\\{q\\}} $"),". Then, we apply a specific affine transformation ",r.a.createElement(p,null,"$ {\\color{green}\\{q\\}} \\to {\\color{green}\\{r\\}} $"),". This transformation is best understood as taking the sum of rotations of the byte representing the number, with a constant at the end. The matrix below shows the transformation with respect to the natural basis ",r.a.createElement(p,null,"$ \\{01, 02, 04, ..., 80\\}$ of $\\mathbb{F}(2^8)$.")),over:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,'Why is this a "natural choice of basis"? What we are doing here is considering ',r.a.createElement(p,null,"$\\mathbb{F}(2^8)$")," a vector space over ",r.a.createElement(p,null,"$\\mathbb{F}(2)$"),", using the isomorphism from earlier. The choice of basis induced by that map is ",r.a.createElement(p,null,"$ \\{1, x, x^2, ..., x^7\\} = \\{01, 02, 04, ..., 80\\}$"),"."),r.a.createElement("p",null,'What do we mean about the "sum of rotations"? Have a think about how we might reformulate this in terms of byte rotations :) '))}),r.a.createElement(p,{displayMode:!0},"$$\n                \\begin{bmatrix} r_0\\\\r_1\\\\r_2\\\\r_3\\\\r_4\\\\r_5\\\\r_6\\\\r_7 \\end{bmatrix}\n                =\n                \\begin{bmatrix} 1&0&0&0&1&1&1&1\\\\1&1&0&0&0&1&1&1\\\\1&1&1&0&0&0&1&1&\\\\1&1&1&1&0&0&0&1\\\\1&1&1&1&1&0&0&0\\\\0&1&1&1&1&1&0&0\\\\0&0&1&1&1&1&1&0\\\\0&0&0&1&1&1&1&1 \\end{bmatrix}\n                \\begin{bmatrix} q_0\\\\q_1\\\\q_2\\\\q_3\\\\q_4\\\\q_5\\\\q_6\\\\q_7 \\end{bmatrix}\n                +\n                \\begin{bmatrix} 1\\\\1\\\\0\\\\0\\\\0\\\\1\\\\1\\\\0 \\end{bmatrix}\n            $$"),r.a.createElement("p",null,"The widget below implements this transformation."),r.a.createElement(g,{default:"00"}),r.a.createElement("p",null,"In practice, unless we have severe constraints on the amount of data we can store (think embedded systems), we simply store a table of the result of applying both operations consecutively, and look up the value to substitute, for efficiency reasons."),r.a.createElement("p",null,"It's also worth bearing in mind that this substition doesn't necessarily need to be exactly the one given here. The authors of Rijndael chose this one because it gives resistance against both differential and linear cryptanalysis techniques, but other suitable substitutions may be used - this is good reason to believe the NSA didn't build in a back door in the specification!"),r.a.createElement("p",null,"Try the whole SubBytes step below - click anywhere on the state box to edit the initial values."),r.a.createElement("div",{className:"boxContainerOuter"},r.a.createElement("div",{className:"boxContainerInner",onClick:function(){return l(!0)}},"State:",r.a.createElement(u,{key:"in"+h.toString(),data:h})),r.a.createElement("div",{className:"boxContainerInner"},"Output:",r.a.createElement(u,{key:"out"+h.toString(),data:h.map((function(e){return y[e]}))}))),i&&r.a.createElement("div",null,r.a.createElement("div",{className:"fadeBackground",onClick:function(){return l(!1)}}),r.a.createElement("div",{className:"editBoxContainer"},r.a.createElement(b,{initial:h,editHandler:function(e){d(e)}}))))};var x=function(e){var t=e.tex,a=Object(n.useState)(!1),i=Object(o.a)(a,2),l=i[0],s=i[1],c=Object(n.useState)(e.input),m=Object(o.a)(c,2),h=m[0],d=m[1];return r.a.createElement("div",{className:"page"},r.a.createElement("h2",null,"Shift Rows"),r.a.createElement("p",null,'Once we have swapped out elements in the state for others, we want to take each row of the box, and "rotate" it. For Rijndael, we move each element in the ',r.a.createElement(t,null,"$i^{th}$ row $i$")," elements to the left, with the ones going past the edge wrapping back around (the top row is row 0!). Note that when we fill our initial state, we are filling column by column, and so this is quite a significant scrambling of the data!"),r.a.createElement("p",null,"Try it out below. Again, the state box can be edited by clicking on it."),r.a.createElement("div",{className:"boxContainerOuter"},r.a.createElement("div",{className:"boxContainerInner",onClick:function(){return s(!0)}},"State:",r.a.createElement(u,{key:"in"+h.toString(),data:h})),r.a.createElement("div",{className:"boxContainerInner"},"Output:",r.a.createElement(u,{key:"out"+h.toString(),data:function(e){for(var t=Array(e.length),a=0;a<4;a++)for(var n=0;n<4;n++)t[4*a+n]=e[4*a+(n+a)%4];return t}(h)}))),l&&r.a.createElement("div",null,r.a.createElement("div",{className:"fadeBackground",onClick:function(){return s(!1)}}),r.a.createElement("div",{className:"editBoxContainer"},r.a.createElement(b,{initial:h,editHandler:function(e){d(e)}}))))};function $(e){var t=[1,1,0,1,1,0,0,0],a=[],n=p.toBinArray(e);a[0]=n.slice(0);for(var r=1;r<8;r++)n.unshift(0),1===n.pop()&&(n=n.map((function(e,a){return(e+t[a])%2}))),a[r]=n.slice(0);for(var i=new Array(8),l=0;l<8;l++){i[l]=new Array(8);for(var o=0;o<8;o++)i[l][o]=a[o][l]}return{texString:i.map((function(e){return e.join(" & ")})).join("\\\\\n"),times:function(e){for(var t=p.toBinArray(e),n=[0,0,0,0,0,0,0,0],r=0;r<8;r++)t[r]&&(n=p.xorVec(n,a[r]));return p.toInt(n)}}}function k(e){var t=e.tex;return r.a.createElement(t,{className:"multTable",displayMode:!0},"$$\\begin{bmatrix}"+$(e.n).texString+"\\end{bmatrix} $$")}function S(e){var t=Object(n.useState)({text:"",valid:!1}),a=Object(o.a)(t,2),i=a[0],l=a[1];return r.a.createElement("div",{class:"multTableWidget"},r.a.createElement("label",{for:"multTableInput"},"Try it - matrix for: "),r.a.createElement("input",{type:"text",value:i.text,onChange:function(e){if(""===e.target.value)l({text:"",valid:!1});else{var t=parseInt(e.target.value,16);t>=0&&t<256&&l({text:e.target.value,valid:!0})}},placeholder:e.default,id:"inverseInput",style:{width:20}}),i.valid&&r.a.createElement(k,{key:i.text,n:parseInt(i.text,16),tex:e.tex}))}var N=function(e){for(var t=Object(n.useState)(!1),a=Object(o.a)(t,2),i=a[0],l=a[1],s=Object(n.useState)(e.input),c=Object(o.a)(s,2),h=c[0],d=c[1],f=e.tex,v=[3,1,1,2],E=v.slice(0).reverse(),g=[[],[],[],[]],y=0;y<4;y++)for(var w=0;w<4;w++)g[w][y]=E[(3*y+w)%4];for(var x=new Array(4),k=0;k<4;k++){x[k]=new Array(4);for(var N=0;N<4;N++)x[k][N]=g[N][k]}var j=g.map((function(e){return"\\{"+e.join("\\} & \\{")+"\\}"})).join("\\\\\n"),C=v.reduce((function(e,t){return e&&!e.hasOwnProperty(t)&&(e[t]=$(t)),e}),{});return r.a.createElement("div",{className:"page"},r.a.createElement("h2",null,"Mix Columns"),r.a.createElement("p",null,"Here's where things start to get tricky. We now work in ",r.a.createElement(f,null,"$\\mathbb{F}(2^8)[y]$"),", that is, the ring of polynomials with coefficients in ",r.a.createElement(f,null,"$\\mathbb{F}(2^8)$"),". We still really want to be thinking in terms of our isomorphism earlier, so the hex notation introduced will now be very helpful for keeping our two variables ",r.a.createElement(f,null,"$x$ and $y$")," apart in our heads."),r.a.createElement("p",null,"We want to think of each column, in turn, as a polynomial of degree strictly less than 4. To this end, we fix a column, and let its elements be the coefficients in ascending order (i.e., the last value is the coefficient of ",r.a.createElement(f,null,"$y^3$"),")."),r.a.createElement("p",null,"Now, just the notion that we are working with polynomials of a maximum degree should indicate we are again thinking about a quotient ring. Here, we are doing all following calculations in: ",r.a.createElement(f,{displayMode:!0},"$$ R := \\frac{\\mathbb{F}(2^8)[y]}{ ( {\\color{green}\\{01\\}}y^4 + {\\color{green}\\{01\\}} ) }. $$"),"For this step of the algorithm, we want to multiply each column by a fixed element of ",r.a.createElement(f,null,"$R$"),". In Rijndael, this element is",r.a.createElement(f,{displayMode:!0},"$$a(y) = "+v.map((function(e,t){return"{\\color{green}\\{"+e.toString(16)+"\\}}\\cdot y^{"+(3-t).toString()+"}"})).join(" + ")+".$$")),r.a.createElement(m,{under:r.a.createElement("p",null,"Of course, this involves multiplying elements in ",r.a.createElement(f,null,"$\\mathbb{F}(2^8)$"),", which is certainly not trivial, so we need to get hold of the multiplication tables for each coefficient. It is fairly easy to find the representation of an element of ",r.a.createElement(f,null,"$\\mathbb{F}(2^8)$")," as a matrix acting on the vector space ",r.a.createElement(f,null,"$\\mathbb{F}(2)^8$, by considering its action on the standard basis $\\{1, x, ..., x^7\\}$"),". You can enter such an element into the box below to see this representation of it."),over:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"Why for the coefficients? There are only four of them, and once calculated a single time, they can be reused. Along with the observations below, it should be pretty clear that in all but the most memory-sensitive situations, we should be precalculating these three tables."),r.a.createElement("p",null,"See the SubBytes page for an expalanation of why this is a natural basis."))}),r.a.createElement(S,{default:"00",tex:e.tex}),r.a.createElement("p",null,"Notice that the coefficients of ",r.a.createElement(f,null,"$a$")," make for some very easy calculations! Not only is the identity repeated, ",r.a.createElement(f,null,"$ {\\color{green}\\{03\\}}$")," is just the sum of the other two."),r.a.createElement("p",null,"Now the particular choice of quotient ring ",r.a.createElement(f,null,"$R$")," is very nice - since we saw before that all elements in ",r.a.createElement(f,null,"$\\mathbb{F}(2^8)$")," are additively self-inverse, taking this quotient is the same as setting ",r.a.createElement(f,null,"$ {\\color{green}\\{01\\}}={\\color{green}\\{01\\}}y^4$"),", and so the action on each basis element of ",r.a.createElement(f,null,"$R$")," is very easy to work out: the vector expression representing the action of ",r.a.createElement(f,null,"$a$")," on ",r.a.createElement(f,null,"$R$")," viewed as an ",r.a.createElement(f,null,"$\\mathbb{F}(2^8)$")," vector space with respect to the basis ",r.a.createElement(f,null,"$\\{{\\color{green}\\{01\\}} , ..., {\\color{green}\\{01\\}}y^3\\}$")," is:",r.a.createElement(f,{displayMode:!0},"$$\n                    \\begin{bmatrix} b_0\\\\b_1\\\\b_2\\\\b_3 \\end{bmatrix}\n                    =\n                    \\begin{bmatrix} "+j+" \\end{bmatrix}\n                    \\begin{bmatrix} a_0\\\\a_1\\\\a_2\\\\a_3 \\end{bmatrix},\n                $$")),r.a.createElement("p",null,"Have a play with the boxes below, which will apply the full column mixing transformation."),r.a.createElement("div",{className:"boxContainerOuter"},r.a.createElement("div",{className:"boxContainerInner",onClick:function(){return l(!0)}},"State:",r.a.createElement(u,{key:"in"+h.toString(),data:h})),r.a.createElement("div",{className:"boxContainerInner"},"Output:",r.a.createElement(u,{key:"out"+h.toString(),data:function(e){for(var t=new Array(e.length),a=function(a){for(var n=[0,0,0,0],r=function(t){n=p.addVec(n,x[t].map((function(n){return C[n].times(e[4*t+a])})),(function(e,t){return e^t}))},i=0;i<4;i++)r(i);for(var l=0;l<4;l++)t[4*l+a]=n[l]},n=0;n<4;n++)a(n);return t}(h)}))),i&&r.a.createElement("div",null,r.a.createElement("div",{className:"fadeBackground",onClick:function(){return l(!1)}}),r.a.createElement("div",{className:"editBoxContainer"},r.a.createElement(b,{initial:h,editHandler:function(e){d(e)}}))))};var j=function(e){var t=Object(n.useState)(!1),a=Object(o.a)(t,2),i=a[0],l=a[1],s=Object(n.useState)(!1),c=Object(o.a)(s,2),m=c[0],h=c[1],d=Object(n.useState)(e.input.data),f=Object(o.a)(d,2),p=f[0],v=f[1],E=Object(n.useState)(e.input.roundKey),g=Object(o.a)(E,2),y=g[0],w=g[1];return r.a.createElement("div",{className:"page"},r.a.createElement("h2",null,"Add Round Key"),r.a.createElement("p",null,"One very easy final step - we simply need to XOR the state with the round key we generated. Both the input and round key boxes are editable here!"),r.a.createElement("div",{className:"boxContainerOuter"},r.a.createElement("div",{className:"boxContainerInner",onClick:function(){return l(!0)}},"State:",r.a.createElement(u,{key:"in"+p.toString()+y.toString(),data:p})),r.a.createElement("div",{className:"boxContainerInner",onClick:function(){return h(!0)}},"Round Key:",r.a.createElement(u,{key:"in"+p.toString()+y.toString(),data:y})),r.a.createElement("div",{className:"boxContainerInner"},"Output",r.a.createElement(u,{key:"out"+p.toString()+y.toString(),data:function(e,t){for(var a=new Array(e.length),n=0;n<e.length;n++)a[n]=e[n]^t[n];return a}(p,y)}))),i&&r.a.createElement("div",null,r.a.createElement("div",{className:"fadeBackground",onClick:function(){return l(!1)}}),r.a.createElement("div",{className:"editBoxContainer"},r.a.createElement(b,{initial:p,editHandler:function(e){v(e)}}))),m&&r.a.createElement("div",null,r.a.createElement("div",{className:"fadeBackground",onClick:function(){return h(!1)}}),r.a.createElement("div",{className:"editBoxContainer"},r.a.createElement(b,{initial:y,editHandler:function(e){w(e)}}))))};var C=function(){document.title="Interactive AES - asg58";var e=document.createElement("link");e.href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css",e.rel="stylesheet",document.head.appendChild(e);var t=a(3),i=function(){return Array.from({length:16},(function(){return Math.floor(256*Math.random())}))},l=Object(n.useState)("about"),c=Object(o.a)(l,2),u=c[0],m=c[1],d={about:r.a.createElement(s,{className:"page",tex:t}),first:r.a.createElement(h,{className:"page",input:i(),tex:t}),subBytes:r.a.createElement(w,{className:"page",input:i(),tex:t}),shiftRows:r.a.createElement(x,{className:"page",input:i(),tex:t}),mixCols:r.a.createElement(N,{className:"page",input:i(),tex:t}),addRoundKey:r.a.createElement(j,{className:"page",input:{data:i(),roundKey:i()},tex:t})};return r.a.createElement(r.a.Fragment,null,r.a.createElement("div",{class:"topNav"},r.a.createElement("div",{class:"navElt",onClick:function(){return m("about")}},"About"),r.a.createElement("div",{class:"navElt",onClick:function(){return m("first")}},"Prerequisites"),r.a.createElement("div",{class:"navElt",onClick:function(){return m("subBytes")}},"SubBytes"),r.a.createElement("div",{class:"navElt",onClick:function(){return m("shiftRows")}},"ShiftRows"),r.a.createElement("div",{class:"navElt",onClick:function(){return m("mixCols")}},"MixCols"),r.a.createElement("div",{class:"navElt",onClick:function(){return m("addRoundKey")}},"AddRoundKey")),r.a.createElement("div",{id:"main"},d[u]))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));l.a.render(r.a.createElement(r.a.StrictMode,null,r.a.createElement(C,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))}],[[5,1,2]]]);
//# sourceMappingURL=main.a76e4f99.chunk.js.map